# Домашнее задание к занятию 6. «Troubleshooting»## Задача 1Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD-операция в MongoDB и её нужно прервать. Вы как инженер поддержки решили произвести эту операцию:- напишите список операций, которые вы будете производить для остановки запроса пользователя;```Надо использовать db.currentOp() для идентификации запроса и получения его opid, далеее db.killOp(opid) для прерывания запроса по opid.```- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB.```- Индексация: Следить, что коллекции правильно проиндексированы, для  ускорения операции чтения и фильтрации данных.- Оптимизация запросов: Использовать explain() для анализа выполнения запросов. Оптимизировать запросы, насколько возможно. Бывает "коробочный" продукт и запросы фактически исправить нельзя. - Мониторинг: Следить за производительностью системы, нагрузка на ЦП, утилизация ОЗУ, время отклика дисковой системы и т.п.- Использование оптимального оборудования: На основе данных мониторинга оценить насколько достаточна конфигурация сервера для работы БД и  соответствует нагрузке.- Обновление MongoDB: Иногда возможно обновление решает некторые проблемы, если включают улучшения производительности и исправления ошибок.- Ограничение ресурсов: Если есть потолок в ресурсах и нельзя улучшить железо, можно ограничить ресурсы выделяемые запросам, чтобы предотвратить зависание всей системы из-за одного запроса. Это можно сделать через механизм Resource Control. Для этого создается роль с ограничениями, а потом применяется к пользователю или запросу.```## Задача 2Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причём отношение количества записанных key-value-значений к количеству истёкших значений есть величина постоянная иувеличивается пропорционально количеству реплик сервиса. При масштабировании сервиса до N реплик вы увидели, что:- сначала происходит рост отношения записанных значений к истекшим,- Redis блокирует операции записи.Как вы думаете, в чём может быть проблема?```Это связано с алгоритмом удаления ключей с истекшим TTLRedis удаляет просроченные ключи двумя способами:- Ленивый способ: ключ истекает, когда он запрашивается командой, но обнаруживается, что он уже просрочен.- Активный способ: несколько ключей удаляются каждые 100 миллисекунд.Активное удаление ключей настроено на адаптивность. Цикл истечения запускается каждые 100 миллисекунд (10 раз в секунду) и выполняет следующее:Выбирает ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP ключей и удаляет все просроченные ключи.Если более 25% ключей оказываются просроченными, повторяет операцию.Алгоритм адаптивный и будет повторяться, если оказывается, что более 25% ключей просрочены в выборке. Учитывая, что алгоритм запускается десять раз в секунду, это означает, что неудачное событие, когда более 25% ключей в нашей случайной выборке просрочены хотя бы в ту же самую секунду.Это в основном означает, что если в базе данных много ключей, которые истекают в одну и ту же секунду, и они составляют по крайней мере 25% текущего набора ключей с установленным сроком действия, Redis может заблокироваться, чтобы уменьшить процент просроченных ключей до 25%Что делать?:Избегать слишком коротких TTL для ключей.Оптимизировать управление TTL.``` ## Задача 3Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей в таблицах базыпользователи начали жаловаться на ошибки вида:```pythonInterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '```Как вы думаете, почему это начало происходить и как локализовать проблему?Какие пути решения этой проблемы вы можете предложить?```Очевидно что клиент теряет соединение с сервером во время выполнения запроса. Причины возможны разные:- Сетевая недоступность: Проверить, нет ли проблем на уровне сетевой инфраструктуры. Счетчики ошибок на интерфейсах, дропы пакетов и т.п.- Тайм-аут: Большие запросы могут превысить настройки тайм-аута соединения. Увеличить тайм-ауты на стороне клиента и сервера (например, wait_timeout и interactive_timeout в конфигурации MySQL).- Избыточная нагрузка на сервер MySQL: Возможно слишком много одновременных соединений. Увеличить максимальное количество одновременных соединений (max_connections).- Недостаточные ресурсы сервера: При дефиците ЦП/ОЗУ или долгому отклику дисков, он может подвисать и терять соединения. В данном случае надо опираться на монитринг и увеличить ресурсы сервера.- Настройки MySQL: Возможно надо оптимизировать настройки max_execution_time, max_allowed_packet, и net_read_timeout в MySQL.- Блокировка таблицы: Проверить, нет ли запросов, которые блокируют таблицы для других запросов- Логи MySQL: Посмотреть slow_query_log, возможно есть ли какие-либо конкретные запросы которые связаны с разрывами соединений.- Пул соединений: Возможно пул соединений позволит убрать ошибки, т.к. поддерживатет заранее определенное количество активных соединений к БД и предоставляет клиентам готовые соединения для выполнения запросов.Но требуется поддержка со стороны приложения.```## Задача 4Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объёмом данных лучше, чем MySQL.После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:`postmaster invoked oom-killer`Как вы думаете, что происходит?Как бы вы решили эту проблему?```Процесс postmaster был убит системным механизмом OOM-Killer для освобождения памяти(OOM-Killer (Out of Memory Killer)- Настройка параметров использования памяти PostgreSQL: Проверить shared_buffers, work_mem, maintenance_work_mem и другие.- Мониторинг памяти: Отслеживать использование памяти, возможно происходит утечка памяти. Или есть конкртеные запросы или процессы которые потребляют больше всего памяти, но жертвой OOM становится процесс postmaster(поднять его OOMScoreAdjust?).- Масштабирование аппаратных ресурсов: Если мониторинг показывает дефицит ОЗУ и остальные варианты оптимизации исчерпаны добавить ОЗУ или перевести БД на другой хост.```---