# Домашнее задание к занятию 4. «PostgreSQL»## Задача 1Используя Docker, поднимите инстанс PostgreSQL (версию 13). Данные БД сохраните в volume.```bashroot@t450s:/home/user1/devops-netology/virt-homeworks/06-db-04-postgresql# docker compose up -d[+] Running 1/1 ⠿ Container postgres-container  Started                                                                                        0.6sroot@t450s:/home/user1/devops-netology/virt-homeworks/06-db-04-postgresql# docker psCONTAINER ID   IMAGE         COMMAND                  CREATED         STATUS         PORTS                                       NAMES08286028b4bc   postgres:13   "docker-entrypoint.s…"   5 seconds ago   Up 4 seconds   0.0.0.0:5432->5432/tcp, :::5432->5432/tcp   postgres-container```Подключитесь к БД PostgreSQL, используя `psql`.```bashroot@t450s:/home/user1/devops-netology/virt-homeworks/06-db-04-postgresql# docker exec -it postgres-container psql -U user1 -d user1dbpsql (13.12 (Debian 13.12-1.pgdg120+1))Type "help" for help.user1db=# \?```Воспользуйтесь командой `\?` для вывода подсказки по имеющимся в `psql` управляющим командам.**Найдите и приведите** управляющие команды для:- вывода списка БД,```user1db=# \l                             List of databases   Name    | Owner | Encoding |  Collate   |   Ctype    | Access privileges-----------+-------+----------+------------+------------+------------------- postgres  | user1 | UTF8     | en_US.utf8 | en_US.utf8 | template0 | user1 | UTF8     | en_US.utf8 | en_US.utf8 | =c/user1         +           |       |          |            |            | user1=CTc/user1 template1 | user1 | UTF8     | en_US.utf8 | en_US.utf8 | =c/user1         +           |       |          |            |            | user1=CTc/user1 user1db   | user1 | UTF8     | en_US.utf8 | en_US.utf8 |(4 rows)```- подключения к БД,```user1db=# \c user1db user1You are now connected to database "user1db" as user "user1".```- вывода списка таблиц,```user1db=# \dt         List of relations Schema |  Name  | Type  |  Owner--------+--------+-------+---------- public | orders | table | postgres(1 row)```- вывода описания содержимого таблиц,```user1db-# \dS+ orders                                                       Table "public.orders" Column |         Type          | Collation | Nullable |              Default               | Storage  | Stats target | Description--------+-----------------------+-----------+----------+------------------------------------+----------+--------------+------------- id     | integer               |           | not null | nextval('orders_id_seq'::regclass) | plain    |              | title  | character varying(80) |           | not null |                                    | extended |              | price  | integer               |           |          | 0                                  | plain    |              |Indexes:    "orders_pkey" PRIMARY KEY, btree (id)Access method: heap```- выхода из psql.```user1db-# \q```## Задача 2Используя `psql`, создайте БД `test_database`.```root@t450s:/home/user1/devops-netology/virt-homeworks/06-db-04-postgresql# docker exec -it postgres-container psql -U user1 -d user1dbpsql (13.12 (Debian 13.12-1.pgdg120+1))Type "help" for help.user1db=# CREATE DATABASE test_database;CREATE DATABASE```Изучите [бэкап БД](https://github.com/netology-code/virt-homeworks/tree/virt-11/06-db-04-postgresql/test_data).Внутри указан owner postgres, перед восстанрвлением бэкапа создал такую роль.```user1db=# create role postgres;CREATE ROLE```Восстановите бэкап БД в `test_database`.```root@08286028b4bc:/# psql -U user1 -d test_database -f /tmp/test_dump.sqlSETSETSETSETSET set_config------------(1 row)SETSETSETSETSETSETCREATE TABLEALTER TABLECREATE SEQUENCEALTER TABLEALTER SEQUENCEALTER TABLECOPY 8 setval--------      8(1 row)ALTER TABLE```Перейдите в управляющую консоль `psql` внутри контейнера.Подключитесь к восстановленной БД и проведите операцию ANALYZE для сбора статистики по таблице.```root@08286028b4bc:/# psql -U user1 -d test_databasepsql (13.12 (Debian 13.12-1.pgdg120+1))Type "help" for help.test_database=# ANALYZE orders;ANALYZE```Используя таблицу [pg_stats](https://postgrespro.ru/docs/postgresql/12/view-pg-stats), найдите столбец таблицы `orders` с наибольшим средним значением размера элементов в байтах.**Приведите в ответе** команду, которую вы использовали для вычисления, и полученный результат.```test_database=# SELECT attname, avg_widthFROM pg_statsWHERE tablename = 'orders'ORDER BY avg_width DESCLIMIT 1; attname | avg_width---------+----------- title   |        16(1 row)```## Задача 3Архитектор и администратор БД выяснили, что ваша таблица orders разрослась до невиданных размеров ипоиск по ней занимает долгое время. Вам как успешному выпускнику курсов DevOps в Нетологии предложилипровести разбиение таблицы на 2: шардировать на orders_1 - price>499 и orders_2 - price<=499.Предложите SQL-транзакцию для проведения этой операции.Фиксируем состояние до изменений```test_database=# \dS+ orders                                                       Table "public.orders" Column |         Type          | Collation | Nullable |              Default               | Storage  | Stats target | Description--------+-----------------------+-----------+----------+------------------------------------+----------+--------------+------------- id     | integer               |           | not null | nextval('orders_id_seq'::regclass) | plain    |              | title  | character varying(80) |           | not null |                                    | extended |              | price  | integer               |           |          | 0                                  | plain    |              |Indexes:    "orders_pkey" PRIMARY KEY, btree (id)Access method: heap```Выполняем процедуру```test_database=# BEGIN;-- Создаю новую таблицу orders_1, селектом копирую данные из старой в новуюCREATE TABLE orders_1 ASSELECT *FROM ordersWHERE price > 499;-- Создаю новую таблицу orders_2, селектом копирую данные из старой в новуюCREATE TABLE orders_2 ASSELECT *FROM ordersWHERE price <= 499;-- Удаляю исходную таблицуDROP TABLE orders;COMMIT;BEGINSELECT 3SELECT 5DROP TABLECOMMITtest_database=#```Проверям что получилось```test_database=# \dt         List of relations Schema |   Name   | Type  | Owner--------+----------+-------+------- public | orders_1 | table | user1 public | orders_2 | table | user1(2 rows)test_database=# \dS+ orders_1                                         Table "public.orders_1" Column |         Type          | Collation | Nullable | Default | Storage  | Stats target | Description--------+-----------------------+-----------+----------+---------+----------+--------------+------------- id     | integer               |           |          |         | plain    |              | title  | character varying(80) |           |          |         | extended |              | price  | integer               |           |          |         | plain    |              |Access method: heaptest_database=# \dS+ orders_2                                         Table "public.orders_2" Column |         Type          | Collation | Nullable | Default | Storage  | Stats target | Description--------+-----------------------+-----------+----------+---------+----------+--------------+------------- id     | integer               |           |          |         | plain    |              | title  | character varying(80) |           |          |         | extended |              | price  | integer               |           |          |         | plain    |              |Access method: heap```Можно ли было изначально исключить ручное разбиение при проектировании таблицы orders?	Можно, при использовании горизонтального шардирования или партиционирования таблицы, 	где данные автоматически разбиваются на подтаблицы (партиции)	на основе определенного условия, такого как price. ## Задача 4Используя утилиту `pg_dump`, создайте бекап БД `test_database`.```root@08286028b4bc:/# pg_dump -U user1 -d test_database -f /tmp/test_database_backup.sql```Как бы вы доработали бэкап-файл, чтобы добавить уникальность значения столбца `title` для таблиц `test_database`?Добавил уникальность к столбцу title```Блок CREATE TABLE public.orders_1 (    id integer,    title character varying(80),    price integer);Заменить на CREATE TABLE public.orders_1 (    id integer,    title character varying(80) UNIQUE,     price integer);```---